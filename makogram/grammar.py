"""
Grammar-based test case generation using Mako templates 
as the right-hand-sides of grammar productions. 

See README.md for an overview of why we chose Mako for this purpose. 

A grammar is represented by a Grammar object.  Productions for a 
symbol can be provided in one of two ways: 

(1) Grammar.prod(symbol, rhs, ... ) adds a production 
    symbol ::=  rhs
    For example, 
      g = makogram.grammar.Grammar()
      g.prod("tests", "${tests()} ${test()}")
      g.prod("tests", "${test()}")

(1.5) Grammar.kleene(symbol, rhs, reps=k) is a special 
   case of Grammar.prod for a bounded version of 
   Kleene star.  Another way to get 10 repetitions of 
   ${test() } is 
      g.kleene("tests", "${test()}", reps=10)
   or we can draw from 1..5 repetitions uniformly with 
      g.kleene("tests", "${test()}", min=1, max=5)

(2) Procedural attachment: 
      @g.procdef("next_name")
      def next_name():
          return next(names)

Procedural attachment has several uses: 
* Generate concrete values for (terminal) symbols of the grammar, 
  e.g., draw integers from some random distribution. 
* Control the generation process using parameters provided in a 
  prior step, e.g., interpreting some value in a test case 
  specification generated by genpairs.py. 
"""

from mako.template import Template
import random

import logging
logging.basicConfig(format='%(levelname)s:%(message)s',
                        level=logging.WARNING)
log = logging.getLogger(__name__)


class Grammar:
    """
    A generative grammar implemented as a set of 
    Python functions and templates. 
    """
    def __init__(self):
        self.grammar_env = { }  # Functions & attributes we want to pass to Mako
        #
        # Dynamic context of generation
        self.context = None
        self.ctx_stack = [ ]
        # Right-hand-sides for each non-terminal (excluding those
        # defined by procedural attachment, for now)
        self.production_choices = { }

    def procdef(self, name):
        """Make this function visible to Mako templates
           (a 'procedural attachment').  'name' is the symbol 
           that will be used to refer to it in templates.  
           For example, if 'name' is 'T', then this function 
           will be called when rendering a template 
           that contains ${T()}$. 
        """
        def decorate(f):
            self.grammar_env[name] = f
            log.debug("Registered function to term '{}'".format(name))
            return f
        return decorate

    def kleene(self, name, rhs, reps=None, min=0, max=9):
        """
        Repetition of a pattern.  If reps is provided, we 
        repeat it exactly that many times.  Otherwise we choose 
        uniformly between min and max repetitions each time we 
        expand the template. 

        Examples: 
        g.kleene("tests", "${test()}", reps=10)
        g.kleene("tests", "${test()}", min=1, max=5)
        """
        tmpl = Template(rhs)
        if reps:
            def _reps():
                return reps
        else:
            def _reps():
                return random.randint(min, max)
        def _kleene():
            l = [ tmpl.render(**self.grammar_env) for _ in range(_reps()) ]
            return "".join(l)
        self.grammar_env[name] = _kleene

    def _dump_choices(self, choices):
        """
        Debugging: What are our choices? 
        What are the counts so far? 
        """
        counts = self.context["counts"]
        print("All counts: ")
        for count in counts:
            print("{}: {}...".format(counts[count], count[:15]))
        print("Choosing among: ")
        print("weight/limit(count)\t rhs")
        for choice in choices:
            text = choice["text"]
            print("{}/{}({})\t {}".format(choice["weight"],
                                          choice["max_uses"],
                                          counts[text],
                                          text))


    def _choose_rhs(self, choices):
        """
        Internal: Choose among right-hand-side choices, 
        considering limits, weights, etc. 
        Returns an RHS template
        """
        # Some may be eliminated because of limits.
        # Limit counts are associated with the RHS as string,
        # so two occurrences of an RHS in different productions
        # would share a count (but not a limit)
        #
        counts = self.context["counts"]
        log.debug("Choosing among {}, counts = {}".format(choices,counts))
        # First make sure they all have counts.
        for choice in choices:
            text = choice["text"]
            if text not in counts:
                log.debug("Initializing count for {}".format(text))
                counts[text] = 0

        # self._dump_choices(choices)

        allowed = [ ]
        for choice in choices:
            text = choice["text"]
            count = counts[text]
            if choice["max_uses"] >= count:
                log.debug("Allowing {}... with max_uses {} out of {}"
                              .format(choice["text"][0:10],
                                          choice["max_uses"],
                                          count))
                allowed.append(choice)
        if allowed:
            choices = allowed
            log.debug("Unlimited choices narrowed to ... {}".format(choices))
        else:
            log.debug("All choices have limited out")
        if len(choices) == 1:
            log.debug("Only one choice, so we'll take it")
            choice = choices[0]
            template = choice["rhs"]
            text = choice["text"]
            counts[text] += 1
            return template
        # Choose among remaining choices by weight
        weight_sum = 0.0
        for choice in choices:
            weight_sum += choice["weight"]
        threshold = random.random() * weight_sum
        for choice in choices:
            if choice["weight"] >= threshold:
                template = choice["rhs"]
                text = choice["text"]
                counts[text] += 1
                return template
            threshold -= choice["weight"]
        assert(False, "Exhausted choices!")
        

    def prod(self, name, rhs, max_uses=999999, max_depth=999999,
                 weight=1):
        """
        A single production for a term in the grammar, 
        name ::= production 
        with attributes to guide choices in generation.

        The name indexes a collection of productions.  Each
        production is represented as a dictionary, in which the 
        rhs is one attribute. 
        """
        if name not in self.grammar_env:
            choices = [ ]
            self.production_choices[name] = choices
            def _rhs_chooser(): 
                """Capture name and choices in a closure"""
                rhs = self._choose_rhs(choices)
                return rhs.render(**self.grammar_env)
            self.grammar_env[name] = _rhs_chooser            
        else:
            choices = self.production_choices[name]

        choices.append({ "rhs": Template(rhs),
                         "text": rhs, # Index counts by this
                         "max_uses": max_uses, 
                         "max_depth": max_depth,
                         "weight": weight })


    def gen(self,term, context={}):
        """
        Interpret 'term' as a template to be expanded. 
        This is a top-level method that begins generating a new 
        sentence in the grammar.  It establishes a context for 
        the current sentence, which may include state information like 
        current depth of recursion, counts of various terms, etc. 
        Do not call this recursively from within the grammar! 

        Issue:  We need an opportunity to set beginning 
        context.  For now we'll try doing it with an 
        optional (keyword) argument
        """
        if self.context:
            print("Warning: Recursive call to 'gen'")
        self.ctx_stack.append(self.context)
        self.context = dict(context)  # Prevent side effects across calls
        self.context["counts"] = { }
        sentence = self.expand(Template(term))
        self.context = self.ctx_stack.pop()
        return sentence 

    def expand(self,template):
        """
        Expand the template in the context of the 
        functions that have been defined as non-terminals. 
        At the top level, use 'gen' to establish context 
        for the whole sentence.  Use 'expand' to expand a 
        non-terminal in the existing context (e.g., adding 
        to the existing counts rather than starting over). 
        """
        return template.render(**self.grammar_env)

