## Comments


"#" are comments. Anything beyond a "#" is a comment.


## Globals


Globals are declared first, and of form \<Symbol Name\> \<Value\>.


Value can be any type, but the type will be inferred


100 -> int, 100.0 -> float, or specialty objects (Range)


It's probably a good idea to define globals that describe particular parameters. For example, Magnitudes ranges in total from 0.0 to 10.0, but there are different classifications to the general sizes of earthquakes. It may be worth defining a Range object for the parm's total span and subsections of size, for example, a Range object for small earthquakes (0.0, 2.0), medium (4.0, 6.5), and devastating (8.0, 10.0).
The value can also be a custom-defined set, but it must be python-valid code. For example, if the desired data points are strings of days of the week, then it must be represented as a List or String. `[day for day in "MTWRF"]` or `"MTWRF"` would both be acceptable.



## Range Objects
Ranges are helpful objects that merely describe a range of possible values. It is similar to python's built-in range, but this has added functionality of ranging floats, exclusive bounds, and selection of a random point within (the selection type is limited to uniform distribution generation for right now).

## Dimensions


@Horizontal and @Vertical begin to describe the columns and rows of the test case

@Horizontal will describe the number of rows, and the parameter can be named something. The number of rows might be variable, so describing what test sizes you want can be described by percentages of 100 (MAX_GENS). For example, "int many 3" means that a test case that has "many" rows will have exactly 300, and "int few .7" will create a test case that has 70 rows. The number of rows is an int, despite .7 being a float - it merely represents a percentage of MAX_GENS.

@Vertical is all the columns: Parameter Objects and their names


## General Rules


Syntax imitates Grammar Production Rules
`X -> A | B` turns into
```
X:
        A
        B
```

A col is generated by some type, one of all possible distribution types deriving from the pairwise testing vectors. Each distribution type gets mappped to the corresponding function in parmgen module. Each type must have basic parameters supplied to it. 
Uniform needs a low and high bound
Left and Right slant need a low and high bound, and a peak value
Normal needs a low and high bound, plus a mu and sigma value.
The words "low", "high", "ave", "dev", and "peak" are keywords for the arguments to these functions, but they can be any object type. For
example:
```
int low 0
int high 5
```

&

```
float low 0.1
float high 5.5
```

are both valid. In a certain distribution type, the arguments should be similar types (both ints or both floats). It doesn't make sense to generate a uniform distribution ranging from 0 to 5.23555 - and what should the return type of the data point be, float or int?

@Vertical must always be made of col or multicol objects. col will become a Parm object, and multicol will become a Cardioid object in the parmgen module. multicols that are dependent on each have a later subsection that describes their relationship. Each singular multicol must be created first and the joint distribution is enforced later, using a hillclimbing approach (see section on Hillclimbing).


## Reusing types


If multiple cols use the same type function, the arguments to type don't have to be redefined. For example, in cols python_skill and java_skill, they both will use types normal, left_slant, right_slant, normal, and _cardioid at some point when the test vector specifies it. Make sure to describe the arguments to the distribution type after the cols have been defined, for example:

```
python_skill:
        type normal
        type uniform
java_skill:
        type normal
        type uniform
normal: ## this type is used for both python_skill:normal and java_skill:normal
        int low 0
        int high 5
```

If multiple columns use the same type but supply different arguments, the type must be redefined, and the col it belongs to must be notated. For example, magnitudes and depths will both at some point be produced using a normal distribution, but the data points themselves are different. Magnitudes can only range from 0.0 to 10.0, but the depth of an earthquake can be recorded on a completely different scale (Richter points vs. miles below surface). So magnitudes and depths can use the same type keyword "uniform", but the two versions of "uniform" must be marked by <Column Name>~<"type">:

```
Magnitude:
        type uniform
        ...
Depth:
        type uniform
...
Magnitude~uniform:
        float low 0.0
        float high 10.0 
Depth~uniform:
        float low 0.0
        float high 30.0 # a different argument was specified for a type function
```


## Special types


The distribution types of normal, uniform, and two triangular distributions are built-in, but in case a special vaguely non-mathematical distribution is desired, the _cardioid provides for some input on what the most/least frequent data point should be. _cardioid is only used for singular cols (See section on Multiple columns for cols that depend on each other). The favorite, or most frequently occurring data point should be specified, as should the less frequent (occasional), and rare outliers. If no Range or data point is supplied to occasional, points from favorites will take up 90% of the data points, and outliers will take up 10% of the data points. If occasional is supplied, the point spread will be 70/20/10.

The data points themselves can be either a hard value or a Range. If the data point is a Range, points are generated randomly from picks in the Range. The randomly selected value will be different on every data point in the parm, if favorites is Range(0.0, 5.5), the data points will be 4.108, 3.452, 2.890, 3.671, 3.449...
If favorites is a concrete value (for example, 5, or 3.99), that value will occur in 70% (or 90%) of the rows.

The same standard applies to occasional and outliers.
Example:
```
Micro Range(0.0, 2.0] # a global Range object
Magnitude~_cardioid:
        favorites: Micro
        occasional:
        outliers: 3.22
```

## Multiple Columns


If two singular cols have or can have interdependency, the type cardioid is used (different from _cardioid). An interdependency is defined using keywords "prop" and "if" in the definition of the col. If a property is satisfied in one column, the other column will be notified and data points will be generated for the two columns in the joint distribution.
```
magnitude:
        ...
        type cardioid prop magnitude_cardioid

depth:
        ...
        type cardioid if magnitude_cardioid
```
The cardioid type need only be defined once, since both cols share it. The from_set must be a cross product of two sets of possible data points, even if it's the same one. For example {L,M,H}^2 is valid, since it is {L,M,H}*{L,M,H}, which creates all the combinations, LL, LM, LH, ML, MM, MH, HL, HM, HH.

A translation scheme is only necessary if the from_set and favorites are not defined elsewhere. For example, if the from_set is a set of Range objects, a data point will be picked uniformly randomly from that range. For example,
```
North Range[42.2, 45.84]
South Range[42.2, 45.84] # North and South are both Range objects
...

cardioid: #necessary joint distribution - multicol
        from_set: {North,South}*{East,West}
        favorites: North*East
        not: South*West
```
the favorites data points will be a tuple of the form (uniform_pick(North), uniform_pick(East)).

However, if the symbolic points in the from_set has not been defined, it must be.

```
_cardioid:
        favorites: L
        occasional: M 
        outliers: H

cardioid:
        from_set: {L,M,H}^2
        favorites: L*H, H*L, M*M
        not: L*L, H*H

Translate:
        L 0,1,2
        M 3
        H 4,5
```
The translation scheme will turn a tuple (L, H) and translate it into a tuple (uniform_pick(0, 1, 2), uniform_pick(4, 5)) such that the first point will be a point in the first column parm and the second point a point in the second column parm.


# Special Direct Multicols
Some multicols are not multicols because their individual columns have a dependency; they can be a multicol because out of necessity the data points for those cols must be created together and then sorted into the columns the points need to be in. For example, AvailableTimes, which is a collection of columns Monday-Friday. A tester may want to test the trend of normally distributed time, where midday Wednesday is the most frequent freetime, and Mondays and Fridays are not so much free. Given a time range (5 days * 4 time slots per day), parmgen can choose the data points all at once, and then sort one student's free time into the necessary columns, organized by day.

A multicol is noted in this way in the @Vertical declaration using the keyword `direct`. Then when the columns in the multicol need to be described, each column must describe what data points will be in it. For example a data point free time slot of "M 10:00 - 12:00" should be sorted into the Monday column because `col Monday sorted by M`. Columns must be sorted by the leading section of the data point.


## Hillclimbing


Two or more singular columns together may form a multicol, but two multicols that have an interdependency (temporarily called a Super Column) require special handling. A hillclimbing approach is used to enforce distributions between those multicols. So arguments must be supplied to identify more favorable changes. The hillclimbing improvement scheme only occurs after data for the two multicols have been generated; the hillclimbing will then make random swaps of data and evaluate if the swap improves the point spread.

parm1 "<<" parm2 denotes that parm2 (a multicol) has a dependency on parm1 (a different multicol). A function must be supplied to combine cols in the multicol. The function can be as simple as an even averaging, where an average is calculated from a row of data points. Alternative averaging options are still to come. If the two multicols are combined in different ways, two functions must be supplied, comma separated: ```using function even_averaging, weighted_average```.

Then, relational properties are described using "->". A left column data point's classification should imply a right column data point's classification. So imagine that Weather multicol is composed of cols temperature and cloud_cover, and that Activities multicol is composed of activity1 col and activity2 col, and activities can be categorized into collections: AtHome activities (stay inside your house type activities like read_book, cook_dinner, clean_room), Indoors activities (stay inside but at a public place like visit_library, drink_coffee_shop, etc.) and Outdoors activities (hike, run, bike). So the activities available are dependent on the state of the weather.

If the weather is bad, the activities available are fairly limited. But if the weather is good, any activity is at your leisure. So the relational properties must describe what is more favorable to the entire set. Say that this imaginary program desires point spreads such that the activity pursued logically pairs with the outdoor conditions. The dependency rules describe that if a swap matches that relationship, keep the swap because it improves the data set.

```
Weather << Activities
        using...
        Weather::Bad -> Activities::AtHome
        Weather::Okay -> Activities::AtHome | Activities::Indoors
        Weather::Excellent -> Activities::AtHome | Activities::Indoors | Activities::Outdoors
```


## Logical Separation
A long %%%%%%%% is used both as a breakline (to help the writer logically separation parts of their syntax) but also as a tool for the preprocessor to separate definitions. Imagine two cols or multicols that, though they may have a joint cardioid distribution, don't use the same types (distribution types) or even the same kind of data points. A long %%%%%%% helps the preprocessor recognize that the first parm is finished defining itself, and can start understanding the next parm in a new scope.

Example:
```
@Vertical
        col x
        col y

%%%%%%%%%%%%%%%%%%%%%%%%%

x:
        type a
        type b
        type cardioid prop xcard

cardioid:
        from_set: ...
        favorites: ...
        not: ...

%%%%%%%%%%%%%%%%%%%%%%%%%

y:
        type c
        type d
        type cardioid if xcard

```

The long %%%%%%%%% also separates logical spaces between declaration of @Verticals, Hillclimbing rules, and different parms.

One special note is the use of the cardioid. A cardioid ties together two cols, but the type cardioid is defined in the scope of the first col. A long %%%%%%%%% can still be used after that definition, even though the second col of the cardioid creation is separated. This is okay because the from_set that is used for both the first col and second col has already been declared, likely a Global - perhaps a Range object or something different.

