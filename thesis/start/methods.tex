%methods

One key part of this project is deciding if it accomplished its goal and answered its research question. Is using random statistical distributions a valid approach to writing test data? The answer to this question must be supported by observations on the performance and quality of GenSequence. 

Testers might use this tool at any stage during the software development cycle. Perhaps their application is highly advanced, has been neatly designed, and has fixed bug reports found through other means of testing or from end user reports. Therefore, that piece of software simply may not have that many bugs. That is unlikely, but it is possible. So measuring the usefulness of GenSequence on fault finding ability alone would depend on the state of the software it is testing, giving the indication that GenSequence is inadequate when really the software is just really well done.

The intention of this project was to streamline the testing process, and provided automated methods of data creation. The usefulness of this program is measured by the ease of test suite creation. Ultimately it is a tester’s decision as to how useful this project is, but these goals are nearly a self-fulfilling prophecy. More features added to the project only increases the ease of use, since a machine does more of the heavy lifting than a human brain otherwise would have. Nevertheless, there is further discussion later.

Finally, it is important to determine how valid the random statistical distribution approach is. A few case studies will be used to determine if knowing how a parameter’s data was generated helps clarify the expected result. First I will test my testing tool against a planetary orbits simulation. Next I will observe my tools data representation in a earthquake analysis program. Then I will identify open-source projects that have limited testing framework but are legitimate enough to benefit from test data creation, and generate test data for them using my tool. I will also consider these metrics: the length of the script generating data, how much code a tester would have to write, and how quickly the data is generated (more data takes more time).
