#Comments

"#" are comments. Anything beyond a "#" is a comment.

##Globals

Globals are declared first, and of form <Symbol Name> <Value>
Value can be any type, but the type will be inferred
100 -> int, 100.0 -> float, or specialty objects (Range)
It's probably a good idea to define globals that describe particular parameters. For example, Magnitudes ranges in total from 0.0 to 10.0, but there are different classifications to the general sizes of earthquakes. It may be worth defining a Range object for the parm's total span and subsections of size, for example, a Range object for small earthquakes (0.0, 2.0), medium (4.0, 6.5), and devastating (8.0, 10.0)

**************TODO
when declaring globals, particularly from_sets, should they be python-programatically defined or symbolic?
ex: {M, T, W, R, F}*{10:00-12:00, 12:00-2:00, 2:00-4:00, 4:00-6:00}
OR
[str(day + time) for day in ["M", "T", "W", "R", "F"] for time in ["10:00 - 12:00", "12:00 - 2:00", "2:00 - 4:00", "4:00 - 6:00"]]
***************

##Dimensions

@Horizontal and @Vertical begin to describe the columns and rows of the test case

@Horizontal will describe the number of rows, and the parameter can be named something. The number of rows might be variable, so describing what test sizes you want can be described by percentages of 100 (MAX_GENS). For example, "int many 3" means that a test case that has "many" rows will have exactly 300, and "int few .7" will create a test case that has 70 rows. The number of rows is an int, despite .7 being a float - it merely represents a percentage of MAX_GENS.

@Vertical is all the columns: Parameter Objects and their names

##General Rules

Syntax imitates Grammar Production Rules
X -> A | B turns into
X:
        A
        B

A col is generated by some type, one of all possible distribution types deriving from the pairwise testing vectors. Each distribution type gets mappped to the corresponding function in parmgen module. Each type must have basic parameters supplied to it. 
Uniform needs a low and high bound
Left and Right slant need a low and high bound, and a peak value
Normal needs a low and high bound, plus a mu and sigma value.
The words "low", "high", "ave", "dev", and "peak" are keywords for the arguments to these functions, but they can be any object type. For
example:
int low 0
int high 5
&
float low 0.1
float high 5.5

are both valid. In a certain distribution type, the arguments should be similar types (both ints or both floats). It doesn't make sense to generate a uniform distribution ranging from 0 to 5.23555 - and what should the return type of the data point be, float or int?

@Vertical must always be made of col or multicol objects. col will become a Parm object, and multicol will become a Cardioid object in the parmgen module. multicols that are dependent on each have a later subsection that describes their relationship. Each singular multicol must be created first and the joint distribution is enforced later, using a hillclimbing approach (see section on Hillclimbing).

##Reusing types

If multiple cols use the same type function, the arguments to type don't have to be redefined. For example, in cols python_skill and java_skill, they both will use types normal, left_slant, right_slant, normal, and _cardioid at some point when the test vector specifies it. Make sure to describe the arguments to the distribution type after the cols have been defined, for example:
```
python_skill:
        type normal
        type uniform
java_skill:
        type normal
        type uniform
normal: ## this type is used for both python_skill:normal and java_skill:normal
        int low 0
        int high 5
```

If multiple columns use the same type but supply different arguments, the type must be redefined, and the col it belongs to must be notated. For example, magnitudes and depths will both at some point be produced using a normal distribution, but the data points themselves are different. Magnitudes can only range from 0.0 to 10.0, but the depth of an earthquake can be recorded on a completely different scale (Richter points vs. miles below surface). So magnitudes and depths can use the same type keyword "uniform", but the two versions of "uniform" must be marked by <Column Name>~<type>:

```
Magnitude:
        type uniform
        ...
Depth:
        type uniform
...
Magnitude~uniform:
        float low 0.0
        float high 10.0 
Depth~uniform:
        float low 0.0
        float high 30.0 # a different argument was specified for a type function
```

## Special types


The distribution types of normal, uniform, and two triangular distributions are built-in, but in case a special vaguely non-mathematical distribution is desired, the _cardioid provides for some input on what the most/least frequent data point should be. _cardioid is only used for singular cols (See section on Multiple columns).


##Hillclimbing


A hillclimbing approach is used to enforce distributions between multicols. So arguments must be supplied to identify more favorable
changes.
parm1 "<<" parm2 denotes that parm2 has a dependency on parm1. A function must be supplied to combine cols in the multicol. Then 
relational properties are described using "->". 
